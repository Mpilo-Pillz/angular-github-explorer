# AngularGithubExplorer

## Challenge Solution Notes

- I created feature branches branch branching off from the `main` branch. In the workplace I There would have be a dedicated `develop`, `test` and `main` branch representing the different environments such as test, uat and prod.
- For new tasks I created `feature` branches from the most recent version of the `develop` branch to manage individual components of the project.
- I kept the `feature` branches post-merge rather than deleting them. This decision was made to provide reviewers with a clear view of my branching strategy and to demonstrate how I organized my work during the assessment.

### branching

In this project, I use specific tags for branches to organize and manage changes efficiently. Each branch tag corresponds to a specific type of task as outlined below:

**Use Case (UC):** `uc-number/branch-name`
Example: `uc-1/branch-name`
**Description:** These branches are linked directly to use cases specified in the project's assessment notes. They are used for implementing features or fixes directly related to a defined use case.

**Documentation (DOC):** `doc-number/branch-name`
Example: `doc-1/branch-name`
**Description:** These branches are for tasks related to the creation or updating of documentation about the solutions. This might involve updating the project README, code comments, or any external documentation that explains project components.

**Technical Debt (TD):** `td-number/branch-name`
Example: `td-1/branch-name`
**Description:** Used for improving the codebase's readability and maintainability. This could include refactoring code, improving performance, or addressing issues that are not immediate bugs but could hinder future development if not resolved.

_These tags correspond to ticket numbers that are typically autogenerated by task management platforms such as Jira._

### Handling of network requests

- Network requests were managed using `HttpClient`, alongside `Effects` and `RxJS` for handling asynchronous operations.

### Typescript

- In some sections of my code, I used explicit types where TypeScript's type inference was not able to infer the type, while in other areas, I used implicit types where TypeScript could correctly infer them.
- I favor type inference because it maintains a cleaner codebase with fewer code to read. For clarity on types when reading the code, one can utilize the IDEâ€™s capabilities to identify and display the types.
- I kept the default `tsconfig` settings provided with the Angular project setup, choosing not to change the strictPropertyInitialization setting to `false`.
- Explicit types to communicate to users rather than implicit for easier code review on Git. In the input component, I did not need to specify 'text' as the input type, as it defaults to this if no type is specified. However, I opted to specify it to avoid ambiguity.

### Routing

- Angular's built-in Router was used to handle page routing, Auth was out of scope, therefore Auth Guards were not needed as there are no protected routes.

### State management

- RXJS was sufficient for state management, although I would have loved to use NgRx to make it easier to scale this project.

### Semantic HTML

- I was able to use some of the newer html tags using the correct tag for the correct elements or components

### CSS and general ability to produce a polished end result - responsiveness is low priority, but appreciated

- I used `TailwindCSS` to significantly speed up the development process thanks to its utility-first approach. It allowed me to quickly style elements without writing much custom CSS, which might help me achieve a polished look faster.

## Running the Project Locally

This project was generated with [Angular CLI](https://github.com/angular/angular-cli) version 17.2.1.

## Development server

Run `ng serve` for a dev server. Navigate to `http://localhost:4200/`. The application will automatically reload if you change any of the source files.

## Code scaffolding

Run `ng generate component component-name` to generate a new component. You can also use `ng generate directive|pipe|service|class|guard|interface|enum|module`.

## Build

Run `ng build` to build the project. The build artifacts will be stored in the `dist/` directory.

## Running unit tests

Run `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).

## Running end-to-end tests

Run `ng e2e` to execute the end-to-end tests via a platform of your choice. To use this command, you need to first add a package that implements end-to-end testing capabilities.

## Further help

To get more help on the Angular CLI use `ng help` or go check out the [Angular CLI Overview and Command Reference](https://angular.io/cli) page.
